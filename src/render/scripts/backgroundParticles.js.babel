/* global $ */

let canvas
let ctx
let particles = {}

function Particle (radius, x, y, vx, vy) {
  this.radius = radius
  this.x = x
  this.y = y
  this.vx = vx
  this.vy = vy
}

Particle.prototype.update = function () {
  ctx.beginPath()
  ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
  ctx.fillStyle = particles.color
  ctx.fill()

  if (this.x < 0 || this.x > canvas.width) {
    this.vx = -this.vx
  }

  if (this.y < 0 || this.y > canvas.height) {
    this.vy = -this.vy
  }

  this.x += this.vx
  this.y += this.vy

  for (let i = 0; i < particles.nb; i++) {
    const that = particles.array[i]
    const location = Math.sqrt(Math.pow(this.x - particles.reactX, 2) + Math.pow(this.y - particles.reactY, 2))
    const distance = Math.sqrt(Math.pow(this.x - that.x, 2) + Math.pow(this.y - that.y, 2))

    if (location <= particles.reactRadius && distance <= particles.connectDistance) {
      const connectOpacity = 1 - (distance / particles.connectDistance)

      ctx.beginPath()
      ctx.moveTo(this.x, this.y)
      ctx.lineTo(that.x, that.y)
      ctx.strokeStyle = 'rgba(' + particles.connectColor + ',' + connectOpacity + ')'
      ctx.lineWidth = particles.connectWidth
      ctx.stroke()
    }
  }
}

function createParticles () {
  canvas.width = window.innerWidth
  canvas.height = window.innerHeight

  if (particles.nbModeLimit === true) {
    if (particles.nbMod < 0) particles.nbMod = 1
    if (particles.nbMod > 100) particles.nbMod = 100
  }

  particles.nb = Math.round((canvas.width * canvas.height) * (particles.nbMod / 10000))
  particles.array = []

  for (let i = 0; i < particles.nb; i++) {
    const radius = Math.random()
    const x = Math.random() * canvas.width
    const y = Math.random() * canvas.height
    const vx = -0.5 + Math.random()
    const vy = -0.5 + Math.random()

    particles.current = new Particle(radius, x, y, vx, vy)
    particles.array.push(particles.current)
  }

  if ($(canvas).hasClass('is-active')) {
    $(canvas).hide().fadeIn(2000)
  } else {
    $(canvas).addClass('is-active').fadeIn(2000)
    window.requestAnimationFrame(drawParticles)
  }
}

function drawParticles () {
  ctx.clearRect(0, 0, canvas.width, canvas.height)

  for (let i = 0; i < particles.nb; i++) {
    particles.current = particles.array[i]
    particles.current.update()
  }

  window.requestAnimationFrame(drawParticles)
}

function detectMouse () {
  $(window).mousemove(function (canvasPosition) {
    particles.reactX = canvasPosition.pageX
    particles.reactY = canvasPosition.pageY - window.scrollY
  })
}

function detectResize () {
  let documentWidth = $(document).width()
  let documentHeight = $(document).height()

  $(window).resize(function () {
    if (documentWidth !== $(document).width() || documentHeight !== $(document).height()) {
      documentWidth = $(document).width()
      documentHeight = $(document).height()
      createParticles()
    }
  })
}

function backgroundParticles (options = {}) {
  canvas = $(options.canvas).get(0) || $('#background-particles').get(0)
  ctx = canvas.getContext('2d')

  particles = {
    nbMod: options.nbMod || 2,
    nbModLimit: options.nbModLimit || true,
    nbDynamic: options.nbDynamic || true,
    color: options.color || '#422727',
    connectDistance: options.connectDistance || 100,
    connectColor: options.connectColor || '66, 39, 39',
    connectWidth: options.connectWidth || 0.1,
    reactRadius: options.reactRadius || 200
  }

  createParticles()
  detectMouse()
  detectResize()
}

export default backgroundParticles
